<!DOCTYPE html>
<html>
<head>
  <title>Program Copy</title>

 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modern Button Interface</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      height: 100vh;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    .container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      padding: 40px;
      border-radius: 24px;
      width: fit-content;
      box-shadow: 
        0 20px 40px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(255, 255, 255, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.18);
      animation: float 6s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .button-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      max-width: 300px;
    }

    .btn {
      position: relative;
      padding: 18px 24px;
      font-size: 17px;
      font-weight: 600;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      color: white;
      cursor: pointer;
      width: 140px;
      transition: all 0.3s ease;
      overflow: hidden;
      box-shadow: 0 8px 20px rgba(106, 17, 203, 0.3);
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.7s ease;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 25px rgba(106, 17, 203, 0.5);
      background: linear-gradient(135deg, #7a1bdb 0%, #357dfc 100%);
    }

    .btn:active {
      transform: translateY(0);
      transition: transform 0.1s;
    }

    .btn-icon {
      font-size: 18px;
      opacity: 0.9;
    }

    .btn:nth-child(2) {
      background: linear-gradient(135deg, #FF416C 0%, #FF4B2B 100%);
      box-shadow: 0 8px 20px rgba(255, 65, 108, 0.3);
    }

    .btn:nth-child(2):hover {
      box-shadow: 0 12px 25px rgba(255, 65, 108, 0.5);
      background: linear-gradient(135deg, #FF516C 0%, #FF5B3B 100%);
    }

    .btn:nth-child(3) {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      box-shadow: 0 8px 20px rgba(17, 153, 142, 0.3);
    }

    .btn:nth-child(3):hover {
      box-shadow: 0 12px 25px rgba(17, 153, 142, 0.5);
      background: linear-gradient(135deg, #21a99e 0%, #48ff8d 100%);
    }

    .btn:nth-child(4) {
      background: linear-gradient(135deg, #FFA62E 0%, #EA4C89 100%);
      box-shadow: 0 8px 20px rgba(255, 166, 46, 0.3);
    }

    .btn:nth-child(4):hover {
      box-shadow: 0 12px 25px rgba(255, 166, 46, 0.5);
      background: linear-gradient(135deg, #FFB63E 0%, #FA5C99 100%);
    }

    .btn:nth-child(5) {
      background: linear-gradient(135deg, #654ea3 0%, #da98b4 100%);
      box-shadow: 0 8px 20px rgba(101, 78, 163, 0.3);
    }

    .btn:nth-child(5):hover {
      box-shadow: 0 12px 25px rgba(101, 78, 163, 0.5);
      background: linear-gradient(135deg, #755eb3 0%, #eaa8c4 100%);
    }

    .btn:nth-child(6) {
      background: linear-gradient(135deg, #36D1DC 0%, #5B86E5 100%);
      box-shadow: 0 8px 20px rgba(54, 209, 220, 0.3);
    }

    .btn:nth-child(6):hover {
      box-shadow: 0 12px 25px rgba(54, 209, 220, 0.5);
      background: linear-gradient(135deg, #46E1EC 0%, #6B96F5 100%);
    }

    .title {
      text-align: center;
      color: white;
      font-size: 28px;
      margin-bottom: 30px;
      font-weight: 700;
      letter-spacing: 1px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      position: relative;
      display: inline-block;
      left: 50%;
      transform: translateX(-50%);
    }

    .title::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 25%;
      width: 50%;
      height: 3px;
      background: linear-gradient(90deg, transparent, #6a11cb, transparent);
      border-radius: 3px;
    }

    .notification {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: rgba(255, 255, 255, 0.95);
      color: #333;
      padding: 16px 24px;
      border-radius: 12px;
      font-weight: 600;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transition: all 0.4s ease;
      z-index: 100;
      border-left: 5px solid #6a11cb;
    }

    .notification.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    textarea {
      display: none;
    }

    @media (max-width: 600px) {
      .container {
        padding: 30px 20px;
      }
      
      .button-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="title">Quick Actions</div>
  <div class="button-grid">
    <button class="btn" onclick="copy('p1')">
      <span class="btn-icon">↗</span>
      <span>1</span>
    </button>
    <button class="btn" onclick="copy('p2')">
      <span class="btn-icon">↗</span>
      <span>2</span>
    </button>
    <button class="btn" onclick="copy('p3')">
      <span class="btn-icon">↗</span>
      <span>3</span>
    </button>
    <button class="btn" onclick="copy('p4')">
      <span class="btn-icon">↗</span>
      <span>4</span>
    </button>
    <button class="btn" onclick="copy('p5')">
      <span class="btn-icon">↗</span>
      <span>5</span>
    </button>
    <button class="btn" onclick="copy('p6')">
      <span class="btn-icon">↗</span>
      <span>6</span>
    </button>
    <button class="btn" onclick="copy('p7')">
      <span class="btn-icon">↗</span>
      <span>7</span>
    </button>
    <button class="btn" onclick="copy('p8')">
      <span class="btn-icon">↗</span>
      <span>8</span>
    </button>
    <button class="btn" onclick="copy('p9')">
      <span class="btn-icon">↗</span>
      <span>9</span>
    </button>
    <button class="btn" onclick="copy('p10')">
      <span class="btn-icon">↗</span>
      <span>10</span>
    </button>
  </div>
</div>


<!-- Programs stored safely -->
 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->
<textarea id="p1">#include<stdio.h> 
#include<stdlib.h> 
 
int array[50], n = 0; 
 
void create() 
{ 
    printf("Enter the value of n: "); 
    scanf("%d", &n); 
    printf("Enter %d array element: ", n); 
    for(int i = 0; i < n; i++) 
    { 
        scanf("%d", &array[i]); 
    } 
} 
 
void display() 
{ 
    if(n == 0) 
    { 
        printf("Array is empty.\n"); 
        return; 
    } 
    printf("Array elements are: "); 
    for(int i = 0; i < n; i++) 
    { 
        printf("%d ", array[i]); 
    } 
} 
 
void insert() 
{ 
    int value, pos; 
    printf("Enter the element to be inserted: "); 
    scanf("%d", &value); 
    printf("Enter the position: "); 
    scanf("%d", &pos); 
 
    for(int i = n-1; i >= pos-1; i--) 
    { 
        array[i+1] = array[i]; 
    } 
    array[pos-1] = value; 
    n++; 
} 
 
void delete() 
{ 
    int pos; 
    printf("Enter the position to be deleted: "); 
    scanf("%d", &pos); 
    printf("Element %d Deleted.\n", array[pos-1]); 
    for(int i = pos-1; i < n; i++) 
    { 
        array[i] = array[i+1]; 
    } 
    n--; 
} 
 
int main() 
{ 
    int choice; 
    while(1) 
    { 
        printf("\n---Array Operations---\n"); 
        printf("1.Creation\n2.Insertion\n3.Deletion\n4.Display\n5.Exit\n"); 
        printf("Enter your choice: "); 
        scanf("%d", &choice); 
        switch(choice) 
        { 
            case 1: 
                create(); 
                break; 
            case 2: 
                insert(); 
                break; 
            case 3: 
                delete(); 
                break; 
            case 4: 
                display(); 
                break; 
            case 5: 
                exit(0); 
                break; 
            default: 
                printf("Invalid input.\n"); 
                break; 
        } 
    } 
} 
 
</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->


<textarea id="p2">#include<stdio.h> 
#include<string.h> 
 
void compute_lps(char* pattern, int* lps, int m) 
{ 
    int length = 0; 
    int i = 1; 
    lps[0] = 0; 
 
    while(i < m) 
    { 
        if(pattern[i] == pattern[length]) 
        { 
            length++; 
            lps[i] = length; 
            i++; 
        } 
        else 
        { 
            if(length != 0) 
                length = lps[length-1]; 
            else 
            { 
                lps[i] = 0; 
                i++; 
            } 
        } 
    } 
} 
 
void kmp_search(char* pattern, char* text) 
{ 
    int M = strlen(pattern); 
    int N = strlen(text); 
    int lps[M]; 
    compute_lps(pattern, lps, M); 
    int i = 0; 
    int j = 0; 
 
    while(i < N) 
    { 
        if(pattern[j] == text[i]) 
        { 
            i++; 
            j++; 
        } 
        if(j == M) 
        { 
            printf("Pattern found at %d index.\n", i-j); 
            j = lps[j-1]; 
        } 
        else if(i < N && pattern[j] != text[i]) 
        { 
            if(j != 0) 
                j = lps[j-1]; 
            else 
                i++; 
        } 
} 
} 
int main() 
{ 
} 
char text[100], pattern[100]; 
printf("Enter the text: "); 
scanf("%s", text); 
printf("Enter the pattern: "); 
scanf("%s", pattern); 
kmp_search(pattern, text); 
</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->


<textarea id="p3">#include<stdio.h>
#include<stdlib.h>

#define max 5
int stack[5];
int top = -1;

void push()
{
    int value;
    if(top == max-1)
    {
        printf("Stack Overflow.\n");
        return;
    }
    printf("Enter the element to push: ");
    scanf("%d", &value);
    stack[++top] = value;
}

void pop()
{
    if(top == -1)
    {
        printf("Stack underflow.\n");
        return;
    }
    printf("Element %d deleted.\n", stack[top--]);
}

void display()
{
    if(top == -1)
    {
        printf("Stack is Empty.\n");
        return;
    }
    printf("Stack elements: ");
    for(int i = 0; i <= top; i++)
    {
        printf("%d ", stack[i]);
    }
}

int main()
{
    int choice;
    while(1)
    {
        printf("\n\n---Stack Operations---\n");
        printf("1.Push\n2.Pop\n3.Display\n4.Exit\nEnter your choice: ");
        scanf("%d", &choice);
        switch(choice)
        {
            case 1:
                push();
                break;
            case 2:
                pop();
                break;
            case 3:
                display();
                break;
            case 4:
                exit(0);
                break;
            default:
                printf("Invalid input.\n");
                break;
        }
    }
}
</textarea>
 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<textarea id="p4">#include<stdio.h>

int stack[50];
int top = -1;

void push(int x)
{
    if(top < 49)
        stack[++top] = x;
    else
        printf("Stack Overflow\n");
}

int pop()
{
    if(top != -1)
        return stack[top--];
    else
    {
        printf("Stack Underflow\n");
        return -1;
    }
}

int precedence(int x)
{
    if(x == '+'|| x == '-') return 1;
    if(x == '*' || x == '/' || x == '%') return 2;
    if(x == '^') return 3;
    return 0;
}

int main()
{
    char input[50], output[50];
    printf("Enter infix Expression: ");
    scanf("%s", input);

    int i, j = 0;

    for(i = 0; input[i] != '\0'; i++)
    {
        if(
            (input[i] >= 'a' && input[i] <= 'z') ||
            (input[i] >= 'A' && input[i] <= 'Z') ||
            (input[i] >= '0' && input[i] <= '9')
        )
        {
            output[j++] = input[i];
        }
        else if(input[i] == '(')
        {
            push(input[i]);
        }
        else if(input[i] == ')')
        {
            while(top != -1 && stack[top] != '(')
            {
                output[j++] = pop();
            }
            if(top != -1)
                pop();
        }
        else
        {
            while(top != -1 && 
                  (precedence(stack[top]) > precedence(input[i]) ||
                   (precedence(stack[top]) == precedence(input[i]) &&
                    input[i] != '^')))
            {
                output[j++] = pop();
            }
            push(input[i]);
        }
    }

    while(top != -1)
    {
        output[j++] = pop();
    }

    output[j] = '\0';

    printf("Postfix Expression : %s\n", output);
}
</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<textarea id="p5">#include<stdio.h> 
#include<stdlib.h> 
#define MAX 5 
char circular_queue[MAX]; 
int front = -1, rear = -1; 
int isEmpty() 
{ 
} 
if (front == -1 && rear == -1) 
return 1; 
else 
return 0; 
int isFull() 
{ 
} 
if ((rear + 1) % MAX == front) 
return 1; 
else 
return 0; 
void insertElement(char element) 
{ 
    if (isFull()) 
    { 
        printf("Circular Queue Overflow\n"); 
        return; 
    } 
    else if (isEmpty()) 
    { 
        front = rear = 0; 
    } 
    else 
    { 
        rear = (rear + 1) % MAX; 
    } 
    circular_queue[rear] = element; 
} 
 
void deleteElement() 
{ 
    if (isEmpty()) 
    { 
        printf("Circular Queue Underflow\n"); 
        return; 
    } 
    else if (front == rear) 
    { 
        front = rear = -1; 
    } 
    else 
    { 
        front = (front + 1) % MAX; 
    } 
} 
 
void display() 
{ 
    int i; 
    if (isEmpty()) 
    { 
        printf("Circular Queue is empty\n"); 
        return; 
    } 
    printf("Circular Queue elements: "); 
    i = front; 
    do 
    { 
        printf("%c ", circular_queue[i]); 
        i = (i + 1) % MAX; 
    } 
    while (i != (rear + 1) % MAX); 
    printf("\n"); 
} 
 
int main() 
{ 
    int choice; 
    char element; 
    do 
    { 
        printf("\n\n---- Circular Queue Menu ----\n"); 
        printf("1. Insert an Element\n"); 
        printf("2. Delete an Element\n"); 
        printf("3. Display Circular Queue\n"); 
        printf("4. Exit\n"); 
        printf("Enter your choice: "); 
        scanf("%d", &choice); 
 
        switch(choice) 
        { 
        case 1: 
            printf("Enter element to be inserted: "); 
            scanf(" %c", &element); 
            insertElement(element); 
            break; 
        case 2: 
            deleteElement(); 
            break; 
        case 3: 
            display(); 
            break; 
        case 4: 
            printf("Exiting...\n"); 
            break; 
        default: 
            printf("Invalid choice! Please enter a valid option.\n"); 
        } 
    } 
    while(choice != 4); 
 
    return 0; 
}
</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<textarea id="p6"> #include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* newNode(int value) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = value;
    temp->next = NULL;
    return temp;
}

// Insert at front
struct Node* insertFront(struct Node* head, int value) {
    struct Node* new_node = newNode(value);
    new_node->next = head;
    head = new_node;
    return head;
}

// Delete an element if found
struct Node* deleteElement(struct Node* head, int value) {
    if (head == NULL) {
        printf("List is empty.\n");
        return head;
    }

    struct Node* temp = head;
    struct Node* prev = NULL;

    // Case 1: value is in first node
    if (temp != NULL && temp->data == value) {
        head = temp->next;
        free(temp);
        printf("Element %d deleted.\n", value);
        return head;
    }

    // Traverse to find the node
    while (temp != NULL && temp->data != value) {
        prev = temp;
        temp = temp->next;
    }

    // Not found
    if (temp == NULL) {
        printf("Element %d not found in the list.\n", value);
        return head;
    }

    // Delete the node
    prev->next = temp->next;
    free(temp);
    printf("Element %d deleted.\n", value);

    return head;
}

// Search an element
void searchElement(struct Node* head, int value) {
    struct Node* temp = head;
    int pos = 1;

    while (temp != NULL) {
        if (temp->data == value) {
            printf("Element %d found at position %d.\n", value, pos);
            return;
        }
        temp = temp->next;
        pos++;
    }
    printf("Element %d not found in the list.\n", value);
}

// Display list
void displayList(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }
    struct Node* temp = head;
    printf("List elements: ");

    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }

    printf("\n");
}

// Main menu-driven program
int main() {
    struct Node* head = NULL;
    int choice, value;

    while (1) {
        printf("\n--- Singly Linked List Operations ---\n");
        printf("1. Insert at Front\n");
        printf("2. Delete Element\n");
        printf("3. Search Element\n");
        printf("4. Display List\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
        case 1:
            printf("Enter value to insert: ");
            scanf("%d", &value);
            head = insertFront(head, value);
            break;

        case 2:
            printf("Enter value to delete: ");
            scanf("%d", &value);
            head = deleteElement(head, value);
            break;

        case 3:
            printf("Enter value to search: ");
            scanf("%d", &value);
            searchElement(head, value);
            break;

        case 4:
            displayList(head);
            break;

        case 5:
            printf("Exiting...\n");
            exit(0);

        default:
            printf("Invalid choice. Try again.\n");
        }
    }

    return 0;
}

</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<textarea id="p7">#include <stdio.h>
#include <stdlib.h>

/* Structure definition */
struct Node
{
    int data;
    struct Node *previous;
    struct Node *next;
};

/* Global head pointer */
struct Node *head = NULL;

/* Function declarations */
void insertAtBeginning(int value);
void deleteSpecific(int delValue);
void insertLeft(int value, int key);
void display();

/* Insert at beginning */
void insertAtBeginning(int value)
{
    struct Node *newNode;
    newNode = (struct Node *)malloc(sizeof(struct Node));

    newNode->data = value;
    newNode->previous = NULL;

    if (head == NULL)
    {
        newNode->next = NULL;
        head = newNode;
    }
    else
    {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    }
}

/* Delete a specific node */
void deleteSpecific(int delValue)
{
    if (head == NULL)
    {
        printf("\nList is Empty!!! Deletion not possible.");
        return;
    }

    struct Node *temp = head;

    while (temp != NULL && temp->data != delValue)
        temp = temp->next;

    if (temp == NULL)
    {
        printf("\nGiven node not found in the list.");
        return;
    }

    /* Only one node */
    if (head->next == NULL)
    {
        head = NULL;
        free(temp);
    }
    /* First node */
    else if (temp == head)
    {
        head = head->next;
        head->previous = NULL;
        free(temp);
    }
    /* Last node */
    else if (temp->next == NULL)
    {
        temp->previous->next = NULL;
        free(temp);
    }
    /* Middle node */
    else
    {
        temp->previous->next = temp->next;
        temp->next->previous = temp->previous;
        free(temp);
    }

    printf("\nDeletion success!!!");
}

/* Insert a node to the left of given key */
void insertLeft(int value, int key)
{
    if (head == NULL)
    {
        printf("\nList is Empty!!! Insertion not possible.");
        return;
    }

    struct Node *temp = head;

    while (temp != NULL && temp->data != key)
        temp = temp->next;

    if (temp == NULL)
    {
        printf("\nKey value not found in the list.");
        return;
    }

    struct Node *newNode;
    newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;

    /* Inserting before first node */
    if (temp == head)
    {
        newNode->previous = NULL;
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    }
    else
    {
        newNode->next = temp;
        newNode->previous = temp->previous;
        temp->previous->next = newNode;
        temp->previous = newNode;
    }

    printf("\nInsertion success!!!");
}

/* Display the list */
void display()
{
    if (head == NULL)
    {
        printf("\nList is Empty!!!");
    }
    else
    {
        struct Node *temp = head;
        printf("\nList elements are:\n");
        printf("NULL <--- ");

        while (temp->next != NULL)
        {
            printf("%d <===> ", temp->data);
            temp = temp->next;
        }

        printf("%d ---> NULL\n", temp->data);
    }
}

/* Main function */
int main()
{
    int choice, value, key, n, i;

    while (1)
    {
        printf("\n------------------------------");
        printf("\nDOUBLY LINKED LIST OPERATIONS");
        printf("\n------------------------------");
        printf("\n1. Create list (Insert N nodes at beginning)");
        printf("\n2. Delete a node with given data");
        printf("\n3. Insert a node to the left of given key");
        printf("\n4. Display the list");
        printf("\n5. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            printf("\nEnter number of nodes: ");
            scanf("%d", &n);

            for (i = 0; i < n; i++)
            {
                printf("Enter data for node %d: ", i + 1);
                scanf("%d", &value);
                insertAtBeginning(value);
            }
            break;

        case 2:
            printf("\nEnter the data to be deleted: ");
            scanf("%d", &value);
            deleteSpecific(value);
            break;

        case 3:
            printf("\nEnter new node data: ");
            scanf("%d", &value);
            printf("Enter key value: ");
            scanf("%d", &key);
            insertLeft(value, key);
            break;

        case 4:
            display();
            break;

        case 5:
            printf("\nExiting program...");
            exit(0);

        default:
            printf("\nInvalid choice!!!");
        }
    }

    return 0;
}

</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<textarea id="p8">#include <stdio.h>
#include <stdlib.h>

/* Structure definition for BST node */
struct Node
{
    int data;
    struct Node *left;
    struct Node *right;
};

/* Function to create a new node */
struct Node* createNode(int value)
{
    struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

/* Function to insert a node in BST */
struct Node* insert(struct Node *root, int value)
{
    if (root == NULL)
        return createNode(value);

    if (value < root->data)
        root->left = insert(root->left, value);
    else if (value > root->data)
        root->right = insert(root->right, value);
    else
        printf("Duplicate value %d ignored.\n", value);

    return root;
}

/* Inorder Traversal */
void inorder(struct Node *root)
{
    if (root != NULL)
    {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

/* Preorder Traversal */
void preorder(struct Node *root)
{
    if (root != NULL)
    {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

/* Postorder Traversal */
void postorder(struct Node *root)
{
    if (root != NULL)
    {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

/* Search function */
struct Node* search(struct Node *root, int key)
{
    if (root == NULL || root->data == key)
        return root;

    if (key < root->data)
        return search(root->left, key);
    else
        return search(root->right, key);
}

/* Function to find height of the BST */
int height(struct Node *root)
{
    if (root == NULL)
        return -1;

    int leftHeight = height(root->left);
    int rightHeight = height(root->right);

    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}

/* Main function */
int main()
{
    struct Node *root = NULL;
    int choice, key;
    int elements[] = {6, 9, 5, 2, 8, 15, 24, 14, 7, 8, 5, 2};
    int n = sizeof(elements) / sizeof(elements[0]);
    int created = 0;

    while (1)
    {
        printf("\n\n--- BST MENU ---");
        printf("\n1. Create BST");
        printf("\n2. Inorder Traversal");
        printf("\n3. Preorder Traversal");
        printf("\n4. Postorder Traversal");
        printf("\n5. Search an Element");
        printf("\n6. Display Height of BST");
        printf("\n7. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
            case 1:
                if (created)
                {
                    printf("BST already created.\n");
                    break;
                }
                for (int i = 0; i < n; i++)
                    root = insert(root, elements[i]);
                created = 1;
                printf("BST created successfully.\n");
                break;

            case 2:
                if (root == NULL)
                    printf("BST is empty.\n");
                else
                {
                    printf("Inorder Traversal: ");
                    inorder(root);
                }
                break;

            case 3:
                if (root == NULL)
                    printf("BST is empty.\n");
                else
                {
                    printf("Preorder Traversal: ");
                    preorder(root);
                }
                break;

            case 4:
                if (root == NULL)
                    printf("BST is empty.\n");
                else
                {
                    printf("Postorder Traversal: ");
                    postorder(root);
                }
                break;

            case 5:
                printf("Enter key to search: ");
                scanf("%d", &key);
                if (search(root, key) != NULL)
                    printf("Element %d found in BST.\n", key);
                else
                    printf("Element %d NOT found in BST.\n", key);
                break;

            case 6:
                printf("Height of BST = %d\n", height(root));
                break;

            case 7:
                printf("Exiting program...\n");
                exit(0);

            default:
                printf("Invalid choice! Try again.\n");
        }
    }
    return 0;
}

</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<textarea id="p9">#include <stdio.h>

int visited[20];

/* DFS Function */
void DFS(int graph[20][20], int n, int u)
{
    int v;
    printf("%d ", u);
    visited[u] = 1;

    for (v = 0; v < n; v++)
    {
        if (graph[u][v] == 1 && visited[v] == 0)
        {
            DFS(graph, n, v);
        }
    }
}

/* BFS Function */
void BFS(int graph[20][20], int n, int start)
{
    int queue[20], front = 0, rear = 0;
    int visited[20] = {0};
    int u, v;

    queue[rear++] = start;
    visited[start] = 1;

    while (front < rear)
    {
        u = queue[front++];
        printf("%d ", u);

        for (v = 0; v < n; v++)
        {
            if (graph[u][v] == 1 && visited[v] == 0)
            {
                visited[v] = 1;
                queue[rear++] = v;
            }
        }
    }
}

int main()
{
    int graph[20][20];
    int n, i, j, choice, start;

    printf("Enter number of cities (nodes): ");
    scanf("%d", &n);

    printf("Enter adjacency matrix (directed graph):\n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            scanf("%d", &graph[i][j]);
        }
    }

    do
    {
        printf("\n---- MENU ----\n");
        printf("1. Depth First Search (DFS)\n");
        printf("2. Breadth First Search (BFS)\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
            case 1:
                for (i = 0; i < n; i++)
                    visited[i] = 0;

                printf("Enter starting city (node): ");
                scanf("%d", &start);

                printf("Nodes reachable using DFS:\n");
                DFS(graph, n, start);
                printf("\n");
                break;

            case 2:
                printf("Enter starting city (node): ");
                scanf("%d", &start);

                printf("Nodes reachable using BFS:\n");
                BFS(graph, n, start);
                printf("\n");
                break;

            case 3:
                printf("Exiting program...\n");
                break;

            default:
                printf("Invalid choice! Try again.\n");
        }

    } while (choice != 3);

    return 0;
}

</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<textarea id="p10">#include <stdio.h> 
#define MAX 100 
int hashTable[MAX]; 
int m; 
/* Function to insert a key using Linear Probing */ 
void insert(int key) 
{ 
int index, startIndex; 
index = key % m;       
startIndex = index; 
 // Hash function 
while (hashTable[index] != -1) 
{ 
index = (index + 1) % m;   // Linear probing 
if (index == startIndex) 
{ 
printf("Hash table is full. Cannot insert key %d\n", key); 
return; 
} 
} 
hashTable[index] = key; 
printf("Key %d inserted at address %d\n", key, index); 
} 
/* Function to display hash table */ 
void display() 
{ 
int i; 
printf("\nHash Table:\n"); 
for (i = 0; i < m; i++) 
{ 
if (hashTable[i] != -1) 
printf("Address %d : %d\n", i, hashTable[i]); 
else 
printf("Address %d : EMPTY\n", i); 
} 
} 
int main() 
{ 
int n, key, i; 
printf("Enter number of memory locations (m): "); 
scanf("%d", &m); 
// Initialize hash table 
for (i = 0; i < m; i++) 
hashTable[i] = -1; 
printf("Enter number of employee records (N): "); 
scanf("%d", &n); 
printf("Enter %d employee keys (4-digit integers):\n", n); 
for (i = 0; i < n; i++) 
{ 
} 
scanf("%d", &key); 
insert(key); 
display(); 
return 0; 
}
</textarea>

 <!-- /////////////////////////////////////////////////////////////////////////////////////////////// -->

<script>
  function copy(id) {
    const text = document.getElementById(id).value;
    navigator.clipboard.writeText(text);
  }
</script>

</body>
</html>


